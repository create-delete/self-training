package level10FinalAssignment.ten4;
/*
распознавание рукописных цифр

Задача:

Реализовать программу для классификации рукописных цифр.
Эта задача уже больше ориентирована на реализацию алгоритма, умение разбираться в таковых.
 Обычно код у студентов получается не очень структурированный.

 Описание задачи
В качестве исследуемого набора данных будет использоваться база изображений рукописных цифр MNIST(http://yann.lecun.com/exdb/mnist/).
Изображения в данной базе имеют разрешение 28x28 и хранятся в виде набора значений оттенков серого.
Вся база разбита на две части: тренировочную, состоящую из 50000 изображений, и тестовую — 10000 изображений.

Для решения этой задачи предлагается реализовать метод k ближайших соседей
(https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_k-%D0%B1%D0%BB%D0%B8%D0%B6%D0%B0%D0%B9%D1%88%D0%B8%D1%85_%D1%81%D0%BE%D1%81%D0%B5%D0%B4%D0%B5%D0%B9 )
— метрический алгоритм для автоматической классификации объектов.
Основным принципом метода ближайших соседей является то, что объект присваивается тому классу, который является наиболее распространённым среди соседей данного элемента.
Соседи берутся исходя из множества объектов, классы которых уже известны, и, исходя из ключевого для данного метода значения k рассчитывается, какой класс наиболее многочислен среди них.
В качестве расстояния между объектами можно использовать Евклидову метрику, то есть привычное нам расстояние между точками в пространстве.

Требования

Необходимо написать программу, которая будет распознавать рукописные цифры.
Должна быть возможность инициализировать некий класс данными для обучения и предоставить метод для распознавания одного изображения.

Кроме самой реализации алгоритма, следует написать код для проверки его точности (посчитать error rate).
Для этого следует использовать 10000 тестовых изображений.
Кроме вычисления точности предлагается провести эксперимент:
вместо евклидовой метрики использовать расстояние городских кварталов, угол между векторами или что-то еще, и проверить качество распознавания.

Дополнительно

Если всё хорошо работает, то можно ещё немного усложнить задание. Добавив, к примеру, отсев шума (выбросов) или использование метода Парзеновского окна для повышения точности.
 */
public class Main {
}
